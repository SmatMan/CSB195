---
title: "Report 1"
subtitle: "Comparing alternative genetic codes to the Standard Genetic Code"
author: "Arjun Mehandiratta"
date: last-modified
execute: 
  cache: true
jupyter: python3
format:
  html:
    theme: pulse
    page-layout: full
    toc: true
    number-sections: true
    code-fold: false
    code-summary: "Show the code"
    include-in-header:
      text:  |
        <style>
          .version-info {
            font-size: 70%;
            color: #BBBBBB;
            margin-top: -10px;
          }
          .quarto-code-block {
            background: #222;
            color: #f8f8f2;
            border-radius: 6px;
            padding: 1em;
            border: 1px solid #444;
            font-size: 1em;
          }
          .quarto-code-block code {
            background: none;
            color: inherit;
          }
        </style>
---

::: version-info
Last updated {{< meta date >}}.
:::

# Overview
- This project's goal is to evaluate how optimal the Standard Genetic Code **(SGC)** is when compared to other random genetic codes.
- The analysis displays that the SGC is much more well optimized against point mutations than random alternatives.

# Specification
- My specification for the primary experiment is below, I will summarize it briefly underneath.

  ```
  The goal of this project is to compare the Standard Genetic Code (SGC) to other, 
  randomly generated codes that are biologically plausible. 
  We will do so by the following general specification.


  Variables:
    - BASE_DIR = base directory of project
    - aaSimilarity = PCAs of amino acid similarities
    - dtable = lookup table of single letter amino acids showing distance from each other
    - SGC = standard genetic code of form: {'CODON': "AMINO ACID"} 
            where amino acids are in single letter form 
  Functions:
    - ALREADY BUILT! construct_aa_table(dat: pd.DataFrame) -> pd.DataFrame
      - Constructs a pandas dataframe from imported csv stored in aaSimilarity, 
        containing a 21x21 matrix of Euclidean distances between amino acids
        The function calculates the distance between 20 standard amino acids based on 
        12 principal components and adds a 'STOP' codon.
    - ALREADY BUILT! aaSim(aa1: str, aa2: str) -> np.float64
      - Looks up the values in the dataframe constructed earlier in `dtable`
        and returns the applicable stored distance between aa1, aa2; amino acids
    - create_genetic_code(sc_limit: int) -> dict
      - Creates a random genetic code config that maps all 64 codons to all 
        20 amino acids (in single letter form) + at least one stop codon 
        (allow 1-`sc_limit` stop codons).
        Return as a python dict e.g. {'ATA': 'A', 'ATT': 'W'}
    - score_gc(gc: dict) -> np.float64
      - Provides a 'score' of the provided genetic code in `gc`. 
      It must calculate the cost of every possible codon mutation (3 codon mutations 
      per 3 codons), then use aaSim() between the gc-mapped amino acid of the original codon 
      and the gc-mapped amino acid of the mutated codon 
      to determine what the distance between each mutation is. 
      Sum up the distances of every possible mutation and return as np.float64 
  ```

# Setting Up the Environment
## Some constants
- I import some packages and add some constants to begin. STOP_CODON_LIMIT determines the max of how many stop codons the generator will try to assign.
  ```{python}
  import sys
  import statistics as stats
  import pandas as pd
  import numpy as np
  import random
  from itertools import product
  import matplotlib.pyplot as plt

  BASE_DIR = "~/Documents/School/CSB195"
  STOP_CODON_LIMIT = 3

  SGC = {
      'ATA': 'I', 'ATC': 'I', 'ATT': 'I', 'ATG': 'M',
      'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',
      'AAC': 'N', 'AAT': 'N', 'AAA': 'K', 'AAG': 'K',
      'AGC': 'S', 'AGT': 'S', 'AGA': 'R', 'AGG': 'R',
      'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',
      'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',
      'CAC': 'H', 'CAT': 'H', 'CAA': 'Q', 'CAG': 'Q',
      'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',
      'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',
      'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',
      'GAC': 'D', 'GAT': 'D', 'GAA': 'E', 'GAG': 'E',
      'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',
      'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',
      'TTC': 'F', 'TTT': 'F', 'TTA': 'L', 'TTG': 'L',
      'TAC': 'Y', 'TAT': 'Y', 'TAA': '*', 'TAG': '*',
      'TGC': 'C', 'TGT': 'C', 'TGA': '*', 'TGG': 'W',
  }
  ```
## Importing the data
- Since the original data was in .Rds format, I used R's write.csv() command to export `dat/aaFeatureSpace.2025.Rds` to `dat/aaFeatureSpace.csv`
- Python accesses this data and constructs a similarity lookup table using the following code:
  ```{python}
  #| code-fold: true
  def construct_aa_table(dat: pd.DataFrame) -> pd.DataFrame:
    """
    Constructs a 21x21 matrix of Euclidean distances between amino acids.

    The function calculates the distance between 20 standard amino acids based on 
    12 principal components and adds a pseudo 'STOP' codon.

    Args:
        dat: A pandas DataFrame with amino acid single-letter codes as the index 
             and 12 principal components (PC1-PC12) as columns.

    Returns:
        A 21x21 pandas DataFrame containing the Euclidean distances between all 
        20 amino acids and a 'STOP' codon.
    """
    # --- FIX ---
    # Ensure that the dataframe values are numeric before calculations
    # This prevents the TypeError during vector subtraction.
    dat_numeric = dat.apply(pd.to_numeric, errors='coerce')
    # It's good practice to check if coercion created any NaN values
    if dat_numeric.isnull().values.any():
        print("Warning: Non-numeric values were found and converted to NaN.")

    # Define the constant for calculating the distance to the stop codon
    STOP_DIST = 1.5

    # Extract the list of amino acids from the input DataFrame's index
    amino_acids = dat_numeric.index.tolist()

    # Initialize an empty square DataFrame to hold the distances
    dist_matrix = pd.DataFrame(index=amino_acids, columns=amino_acids, dtype=float)

    # Calculate the Euclidean distance for each pair of amino acids
    for aa1 in amino_acids:
        for aa2 in amino_acids:
            # Retrieve the 12-dimensional vectors for the two amino acids
            vec1 = dat_numeric.loc[aa1].values
            vec2 = dat_numeric.loc[aa2].values
            
            # Compute the Euclidean distance and store it in the matrix
            distance = np.linalg.norm(vec1 - vec2)
            dist_matrix.loc[aa1, aa2] = distance

    # Find the maximum distance value among the amino acids
    max_dist = dist_matrix.values.max()

    # Calculate the distance for the stop codon
    stop_codon_dist = STOP_DIST * max_dist
    
    # Add a 'STOP' column and row to the matrix
    stop_label = '*'
    dist_matrix[stop_label] = stop_codon_dist
    dist_matrix.loc[stop_label] = stop_codon_dist
    
    # The distance from 'STOP' to itself is 0
    dist_matrix.loc[stop_label, stop_label] = 0.0

    return dist_matrix

  aaSimilarity = pd.read_csv(f"{BASE_DIR}/dat/aaFeatureSpace.csv", index_col=0)
  dtable = construct_aa_table(aaSimilarity)
  ```
- Now the lookup table is constructed nicely and stored in `dtable`:
  ```{python}
  #| column: page
  dtable
  ```
## Generator and Scorer
- Now we can define the generator function with the following:
  ```{python}
  #| code-fold: true
  def create_genetic_code(sc_limit: int) -> dict:
    """
    Creates a random genetic code config that maps all 64 codons to all 
    20 amino acids and at least one stop codon.

    Args:
        sc_limit: The maximum number of stop codons allowed (the actual
                  number will be chosen randomly between 1 and sc_limit).

    Returns:
        A dictionary mapping each of the 64 codons to a single-letter 
        amino acid code or a stop codon ('*').
        
    Raises:
        ValueError: If sc_limit is not within a reasonable range (1 to 10).
    """
    # Validate the stop codon limit to a sensible range
    if not 1 <= sc_limit <= 10:
        raise ValueError("sc_limit must be between 1 and 10 for practical genetic codes.")

    # Define the building blocks for the genetic code
    bases = ['A', 'T', 'G', 'C']
    amino_acids = list("ACDEFGHIKLMNPQRSTVWY")  # 20 standard amino acids
    stop_symbol = '*'

    # 1. Generate all 64 possible codons
    all_codons = [''.join(p) for p in product(bases, repeat=3)]
    random.shuffle(all_codons)

    # 2. Determine the number of stop codons
    num_stop_codons = random.randint(1, sc_limit)

    # 3. Create the pool of assignments (amino acids + stops)
    # Ensure all 20 amino acids are present at least once
    assignments = amino_acids.copy()
    
    # Add the stop codons
    assignments.extend([stop_symbol] * num_stop_codons)

    # Fill the remaining slots with random amino acids to reach 64 total assignments
    remaining_slots = 64 - len(assignments)
    assignments.extend(random.choices(amino_acids, k=remaining_slots))
    
    # Shuffle the assignments to ensure randomness
    random.shuffle(assignments)

    # 4. Create the dictionary by mapping codons to assignments
    genetic_code = dict(zip(all_codons, assignments))
    
    return genetic_code
  ```
- And we can see that running this function generates us a nice randomly assigned genetic code:
  ```{python}
  test_code = create_genetic_code(2) # with max 2 stop codons
  pd.DataFrame([test_code]) # display nicely
  ```
- Next is the scorer function, defined as follows:
  ```{python}
  #| code-fold: true
  def score_gc(gc: dict) -> np.float64:
    """
    Calculates a 'robustness' score for a genetic code.

    The score is the sum of physicochemical distances between amino acids 
    resulting from all possible single-nucleotide point mutations across all 
    64 codons. A lower score indicates a more robust code where mutations 
    tend to result in similar amino acids.

    Args:
        gc: A dictionary mapping 64 codons to single-letter amino acid codes.
        dtable: A DataFrame containing the pairwise distances between amino acids,
                as created by the `construct_aa_table` function.

    Returns:
        A np.float64 value representing the total cost of all possible mutations.
        
    Raises:
        ValueError: If a codon in the genetic code is not found in the distance table.
    """
    bases = ['A', 'T', 'G', 'C']
    total_distance_cost: float = 0.0

    # Generate all 64 codons
    all_codons = [''.join(p) for p in product(bases, repeat=3)]

    for original_codon in all_codons:
        # Get the amino acid for the original, unmutated codon
        original_aa = gc.get(original_codon)
        if original_aa is None:
            raise ValueError(f"Codon '{original_codon}' not found in the provided genetic code.")

        # Iterate through each of the 3 positions in the codon
        for i in range(3):
            original_base = original_codon[i]
            # Iterate through each possible mutation at that position
            for mutated_base in bases:
                # We only care about actual mutations, not silent changes
                if original_base != mutated_base:
                    # Construct the mutated codon
                    mutated_codon_list = list(original_codon)
                    mutated_codon_list[i] = mutated_base
                    mutated_codon = "".join(mutated_codon_list)
                    
                    # Get the amino acid for the new, mutated codon
                    mutated_aa = gc.get(mutated_codon)
                    if mutated_aa is None:
                        raise ValueError(f"Mutated codon '{mutated_codon}' not found in the provided genetic code.")
                    
                    # Use aaSim to get the distance and add it to the total cost
                    # Note: We are directly using the dtable here as aaSim is just a lookup
                    distance: np.float64 = dtable.at[original_aa, mutated_aa]
                    total_distance_cost += distance

    return np.float64(total_distance_cost)
  ```
- To ensure this function works, we will test the Standard Genetic Code against the baseline in the next section

## Ensuring Baseline
- The baseline score for the SGC was defined in class as `9856.116`. In order to ensure nothing has gone wrong, we will test our functions to see if it returns the same score.
- Since we already have the SGC defined in `SGC` from the constants earlier, we will use that here. 
  ```{python}
  #| column: page
  pd.DataFrame([SGC])
  ```
- Scoring it provides us with the following:
  ```{python}
  score_gc(SGC)
  ```
- Hooray! We can see the code has scored the Standard Genetic Code equal to the baseline!! (to an even more precise figure!).

# Data

## Comparing Random Codes to the SGC
- Let's create a helper function to generate and test random GCs called `gen_and_score(times)`; where `times` is the amount of trials to run.
  ```{python}
  #| code-fold: true
  def gen_and_score(times: int) -> list:
      scores = []
      while len(scores) < times:
          gc = create_genetic_code(STOP_CODON_LIMIT)
          scores.append(float(score_gc(gc)))
      return scores
  ```
- Now, let's generate 1000 random genetic codes, score them, and plot them on a graph. 
  ```{python}
  attempts = 1000
  scores = gen_and_score(attempts)
  ```
  ```{python}
  plt.hist(scores, bins=40, edgecolor='black')
  plt.title(f'Distribution of Genetic Code Scores (n={attempts})')
  plt.xlabel('Score')
  plt.ylabel('Frequency')
  plt.show()
  ```
- This is nice! We get a nice bell curve, and we can see the scores average between 12,000 and 15,000. These scores are MUCH higher than the SGC's score, however. Let's plot the SCG score as well to visualize this.
  ```{python}
  scores.append(score_gc(SGC))
  plt.hist(scores, bins=50, edgecolor='black')
  plt.title(f'Distribution of Genetic Code Scores (n={attempts})')
  plt.xlabel('Score')
  plt.ylabel('Frequency')
  plt.show()
  ```
- Our random codes score *significantly* worse than the standard genetic code. Let's try generating more codes (5000) to try to brute-force optimize...
  ```{python}
  attempts = 5000
  scores = gen_and_score(attempts)
  ```
  ```{python}
  plt.hist(scores, bins=40, edgecolor='black')
  plt.title(f'Distribution of Genetic Code Scores (n={attempts})')
  plt.xlabel('Score')
  plt.ylabel('Frequency')
  plt.show()
  ```
- We get a wider distribution with more attempts, however when compared to the SGC:
  ```{python}
  scores.append(score_gc(SGC))
  plt.hist(scores, bins=60, edgecolor='black')
  plt.title(f'Distribution of Genetic Code Scores (n={attempts})')
  plt.xlabel('Score')
  plt.ylabel('Frequency')
  plt.show()
  ```
- We can clearly see that the Standard Genetic Code is extremely well optimized when compared to random genetic codes.

# Optimization *(extras)*
## Random "Optimization"
- I tried to make an "optimization" function. Truly all it is is a while True loop that randomly generates codes, keeps score of the best one its found, and keeps going until the user keyboard interrupts. So it's not really optimization, rather brute force.

- Regardless, let's see how low of a score it can find. Since this quarto document doesn't have a way to signal interrupt, I will limit the function to 10000 runs.

  ```{python}
  def random_optimization(attempts) -> np.float64:
    best: dict = create_genetic_code(STOP_CODON_LIMIT)
    best_score = score_gc(best)
    tries = 0
    while tries <= attempts:
      try:
          tries += 1
          test = create_genetic_code(STOP_CODON_LIMIT)
          test_score = score_gc(test)
          
          if test_score < best_score:
              best = test.copy()
              best_score = test_score
      except KeyboardInterrupt:
          print(f"{tries} total tries")
          sys.exit()
    print(f"Best code: {best}")
    print(f"Best score: {best_score}")

  random_optimization(10000)
  ```

- I have no way of knowing the exact amount when the quarto doc renders, but in my testing I rarely got better than 11000. Let's try 100,000 attempts...

  <!-- ```{python}
  random_optimization(100000)
  ``` -->

- This has even more chance of randomly stumbling upon a valid genetic code, however in my testing it rarely gets any better than it did in 10,000 attempts. This *significantly* displays how unlikely the SGC's highly optimized score is. 

- So let's try something better.

## Simulated Annealing
- We discussed simulated annealing in class. I could NOT write this function myself, so I got Gemini 2.5 Pro to write it for me. My prompt was:

  ```
  # PROMPT
  I created an example "optimization" function that attempts to find the lowest score:

  def random_optimization() -> np.float64:
      best: dict = create_genetic_code(STOP_CODON_LIMIT)
      best_score = score_gc(best)
      tries = 0
      while True:
          try:
              tries += 1
              test = create_genetic_code(STOP_CODON_LIMIT)
              test_score = score_gc(test)
              
              if test_score < best_score:
                  best = test.copy()
                  best_score = test_score
                  print(f"New best! {best_score}")
                  print(best)
          except KeyboardInterrupt:
              print(f"{tries} total tries")
              sys.exit()

  I would like a function similar to this that, rather than creating random genetic codes, generates one first and then performs "simulated annealing" to optimize the code intelligently.
  ```
  
- And running it results in:

  ```{python}
  #| column: page
  def simulated_annealing_optimization(
      stop_codon_limit: int, 
      initial_temp: float = 10000.0, 
      cooling_rate: float = 0.999, 
      min_temp: float = 1e-4, 
      max_iterations: int = 50000
  ) -> tuple[list, list, list]:
      """
      Optimizes a genetic code using a simulated annealing algorithm to minimize mutation cost.

      Args:
          stop_codon_limit: The maximum number of stop codons for creating new codes.
          initial_temp: The starting temperature for the annealing process.
          cooling_rate: The rate at which the temperature decreases.
          min_temp: The temperature at which to stop the process.
          max_iterations: The maximum number of iterations to run.

      Returns:
          A tuple containing the final best score and a list of scores at each iteration.
      """
      # 1. Initialization
      current_code = create_genetic_code(stop_codon_limit)
      current_score = score_gc(current_code)
      
      best_code = current_code.copy()
      best_score = current_score
      
      # List to track the score at every iteration
      score_history = [current_score]
      
      print(f"Initial score: {best_score}")

      T = initial_temp
      iteration = 0
      
      try:
          # 2. Main Loop
          while T > min_temp and iteration < max_iterations:
              iteration += 1

              # 3. Generate a Neighbor State
              new_code = current_code.copy()
              codons = list(new_code.keys())
              codon1, codon2 = random.sample(codons, 2)
              new_code[codon1], new_code[codon2] = new_code[codon2], new_code[codon1]

              # 4. Score the New State
              new_score = score_gc(new_code)
              
              # 5. Decide Whether to Accept the New State
              score_delta = new_score - current_score
              
              if score_delta < 0 or random.random() < np.exp(-score_delta / T):
                  current_code = new_code
                  current_score = new_score
              
              # Update the best-ever score if the current one is better
              if current_score < best_score:
                  best_score = current_score
                  best_code = current_code.copy()
                  print(f"Iter {iteration} | Temp {T:.4f} | New best score: {best_score:.4f}")

              # Track the score of the accepted state for this iteration
              score_history.append(float(current_score))

              # 6. Cool Down
              T *= cooling_rate

      except KeyboardInterrupt:
          print("\nOptimization stopped by user.")

      finally:
          print(f"\nFinished after {iteration} iterations.")
          print(f"Final best score: {best_score}")
          return (best_score, score_history, best_code)
    
  best_found_score, score_runs, best_found_code = simulated_annealing_optimization(1)
  
  def plot_optimization_progress(runs: list, sgc_score: float):
    plt.figure(figsize=(12, 7))
    plt.plot(runs, linestyle='-', label='Score per Iteration')
    plt.axhline(y=sgc_score, color='r', linestyle='--', label=f'SGC Score ({sgc_score:.2f})')
    plt.title('Simulated Annealing Optimization Progress')
    plt.xlabel('Iteration')
    plt.ylabel('Genetic Code Score')
    plt.legend()
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    plt.show()

  sgc_baseline_score = score_gc(SGC)
  plot_optimization_progress(score_runs, sgc_baseline_score)

  ```

- This is INCREDIBLY satisfying to watch happen, as once you hit a minimum point it *quickly* falls to a low value. 
- On the plot above, it's clear that finding a code optimized better than the SGC isn't that hard. It's important to note that this is only optimized by the standards of the scoring function. It's possible that this code might suck by evolution's standards.

- Let's see what the codon map looks like:

  ```{python}
  #| column: page
  def format_genetic_code_table(gc: dict) -> pd.DataFrame:
    """Formats a genetic code dictionary into a standard 4x4 table."""
    bases = ['T', 'C', 'A', 'G']
    
    aa_map = {
        'A': 'Ala', 'R': 'Arg', 'N': 'Asn', 'D': 'Asp', 'C': 'Cys',
        'E': 'Glu', 'Q': 'Gln', 'G': 'Gly', 'H': 'His', 'I': 'Ile',
        'L': 'Leu', 'K': 'Lys', 'M': 'Met', 'F': 'Phe', 'P': 'Pro',
        'S': 'Ser', 'T': 'Thr', 'W': 'Trp', 'Y': 'Tyr', 'V': 'Val',
        '*': 'Stop'
    }
    
    table_data = []
    for first_base in bases:
        row = []
        for second_base in bases:
            cell_text = []
            for third_base in bases:
                codon = first_base + second_base + third_base
                single_letter_aa = gc.get(codon, '?')
                three_letter_aa = aa_map.get(single_letter_aa, '???')
                cell_text.append(f"{three_letter_aa} ({third_base})")
            row.append("<br>".join(cell_text))
        table_data.append(row)
        
    df = pd.DataFrame(table_data, 
                      index=pd.Index(bases, name="First Base"), 
                      columns=pd.Index(bases, name="Second Base"))
    
    from IPython.display import HTML
    return HTML(df.to_html(escape=False))

  format_genetic_code_table(best_found_code)
  ```

- And compared to the SCG:

  ```{python}
  #| column: page
  format_genetic_code_table(SGC)
  ```
  
# Conclusions
- The standard genetic code is clearly much better than a randomly generated genetic code.
- However, by the metric we have chosen, it is definitely possible to find a more optimized code, with the earlier function able to find codes with scores lower than 8800.

## Limitations of the experiment
- It is definitely possible that these 'optimized' codes are not better than the SGC by other biological measures. A few of the limitations of this experiment (identified by the AI assistant) include:
  - The scoring function only gives low scores to codes that protect against *single point mutations*. It does not prevent against other mutations, like frameshifts or indels.
  - Amino acid similarity defined in `aaSim()` might not be the most optimal metric to measure. 
  - Other biological pressures on the genetic code may exist, such as:
    - translational efficiency of the code
    - 



# Appendix
## Assumptions
- A lookup table exists created from distances between amino acids from data in PCAs aaFeatureSpace.2025.Rds used in class
- I define my computable measure of tolerance of point mutations as a score that, for any genetic code, determines all possible point shift mutations for each codon, calculates the distances between the original and mutated amino acid (using lookup table) and sums the distances to return the score.
- I explain above how the function create_genetic_code() creates a valid genetic code. To summarize: 20 amino acids are assigned to 20 codons, a random amount of stop codons (as specified) are added, the rest are filled with random amino acids.

## AI Chat Links
- [https://www.perplexity.ai/search/create-a-python-function-const-Y8zPZAC5ReKfUI1nNXVnYg#0](https://www.perplexity.ai/search/create-a-python-function-const-Y8zPZAC5ReKfUI1nNXVnYg#0)
  - Model was always set to `Gemini 2.5 Pro`

## Preparing the report
- Preparing the report was relatively straightforward. I used my AI assistant to help me convert the dataset from R to Python. Then I used its help along with some of my own code to begin making aaSim(), and other functions.
- Writing the code (90% of the report) was the easiest part since I had access to AI. Using extremely specific prompts helped a lot, and it rarely gave me a poor result; likely because of prompts
  - Working at a higher level is possible with AI but it helps to still understand the lower levels of what's going on to be specific in your prompts

## References
