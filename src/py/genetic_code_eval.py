import math
import pandas as pd
import numpy as np
import random
from itertools import product

BASE_DIR = "~/Documents/School/CSB195"

aaSimilarity = pd.read_csv(f"{BASE_DIR}/dat/aaFeatureSpace.csv", index_col=0)

def construct_aa_table(dat: pd.DataFrame) -> pd.DataFrame:
    """
    Constructs a 21x21 matrix of Euclidean distances between amino acids.

    The function calculates the distance between 20 standard amino acids based on 
    12 principal components and adds a pseudo 'STOP' codon.

    Args:
        dat: A pandas DataFrame with amino acid single-letter codes as the index 
             and 12 principal components (PC1-PC12) as columns.

    Returns:
        A 21x21 pandas DataFrame containing the Euclidean distances between all 
        20 amino acids and a 'STOP' codon.
    """
    # --- FIX ---
    # Ensure that the dataframe values are numeric before calculations
    # This prevents the TypeError during vector subtraction.
    dat_numeric = dat.apply(pd.to_numeric, errors='coerce')
    # It's good practice to check if coercion created any NaN values
    if dat_numeric.isnull().values.any():
        print("Warning: Non-numeric values were found and converted to NaN.")

    # Define the constant for calculating the distance to the stop codon
    STOP_DIST = 1.5

    # Extract the list of amino acids from the input DataFrame's index
    amino_acids = dat_numeric.index.tolist()

    # Initialize an empty square DataFrame to hold the distances
    dist_matrix = pd.DataFrame(index=amino_acids, columns=amino_acids, dtype=float)

    # Calculate the Euclidean distance for each pair of amino acids
    for aa1 in amino_acids:
        for aa2 in amino_acids:
            # Retrieve the 12-dimensional vectors for the two amino acids
            vec1 = dat_numeric.loc[aa1].values
            vec2 = dat_numeric.loc[aa2].values
            
            # Compute the Euclidean distance and store it in the matrix
            distance = np.linalg.norm(vec1 - vec2)
            dist_matrix.loc[aa1, aa2] = distance

    # Find the maximum distance value among the amino acids
    max_dist = dist_matrix.values.max()

    # Calculate the distance for the stop codon
    stop_codon_dist = STOP_DIST * max_dist
    
    # Add a 'STOP' column and row to the matrix
    stop_label = '*'
    dist_matrix[stop_label] = stop_codon_dist
    dist_matrix.loc[stop_label] = stop_codon_dist
    
    # The distance from 'STOP' to itself is 0
    dist_matrix.loc[stop_label, stop_label] = 0.0

    return dist_matrix


def aaSim(aa1: str, aa2: str, dtable: pd.DataFrame) -> np.float64:
    """
    aaSim(ilarity) - Looks up and returns the pre-calculated distance between two amino acids.

    Args:
        aa1: A string for the first amino acid code (e.g., 'A', '*').
        aa2: A string for the second amino acid code (e.g., 'C', '*').
        dtable: A pandas DataFrame containing the pairwise amino acid distances,
                as generated by the construct_aa_table() function.

    Returns:
        A float representing the Euclidean distance between the two amino acids.
        
    Raises:
        ValueError: If aa1 or aa2 are not found in the distance table's index.
    """
    try:
        # Use .at for fast, label-based lookup of a single value
        distance = np.float64(dtable.at[aa1, aa2])
        return distance
    except KeyError:
        # Provide a helpful error message if an amino acid code is not found
        raise ValueError(f"One or both amino acids '{aa1}', '{aa2}' not found in the distance table.")
        return -999

def create_genetic_code(sc_limit: int) -> dict:
    """
    Creates a random genetic code config that maps all 64 codons to all 
    20 amino acids and at least one stop codon.

    Args:
        sc_limit: The maximum number of stop codons allowed (the actual
                  number will be chosen randomly between 1 and sc_limit).

    Returns:
        A dictionary mapping each of the 64 codons to a single-letter 
        amino acid code or a stop codon ('*').
        
    Raises:
        ValueError: If sc_limit is not within a reasonable range (1 to 10).
    """
    # Validate the stop codon limit to a sensible range
    if not 1 <= sc_limit <= 10:
        raise ValueError("sc_limit must be between 1 and 10 for practical genetic codes.")

    # Define the building blocks for the genetic code
    bases = ['A', 'T', 'G', 'C']
    amino_acids = list("ACDEFGHIKLMNPQRSTVWY")  # 20 standard amino acids
    stop_symbol = '*'

    # 1. Generate all 64 possible codons
    all_codons = [''.join(p) for p in product(bases, repeat=3)]
    random.shuffle(all_codons)

    # 2. Determine the number of stop codons
    num_stop_codons = random.randint(1, sc_limit)

    # 3. Create the pool of assignments (amino acids + stops)
    # Ensure all 20 amino acids are present at least once
    assignments = amino_acids.copy()
    
    # Add the stop codons
    assignments.extend([stop_symbol] * num_stop_codons)

    # Fill the remaining slots with random amino acids to reach 64 total assignments
    remaining_slots = 64 - len(assignments)
    assignments.extend(random.choices(amino_acids, k=remaining_slots))
    
    # Shuffle the assignments to ensure randomness
    random.shuffle(assignments)

    # 4. Create the dictionary by mapping codons to assignments
    genetic_code = dict(zip(all_codons, assignments))
    
    return genetic_code


if __name__ == "__main__":
    # distance_table = construct_aa_table(dat=aaSimilarity)
    # # print(distance_table.to_string())
    # print(aaSim("A", "W", distance_table))
    # print(aaSim("W", "C", distance_table))