import sys
import statistics as stats
import pandas as pd
import numpy as np
import random
from itertools import product
import matplotlib.pyplot as plt

BASE_DIR = "~/Documents/School/CSB195"
STOP_CODON_LIMIT = 3

SGC = {
    'ATA': 'I', 'ATC': 'I', 'ATT': 'I', 'ATG': 'M',
    'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',
    'AAC': 'N', 'AAT': 'N', 'AAA': 'K', 'AAG': 'K',
    'AGC': 'S', 'AGT': 'S', 'AGA': 'R', 'AGG': 'R',
    'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',
    'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',
    'CAC': 'H', 'CAT': 'H', 'CAA': 'Q', 'CAG': 'Q',
    'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',
    'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',
    'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',
    'GAC': 'D', 'GAT': 'D', 'GAA': 'E', 'GAG': 'E',
    'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',
    'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',
    'TTC': 'F', 'TTT': 'F', 'TTA': 'L', 'TTG': 'L',
    'TAC': 'Y', 'TAT': 'Y', 'TAA': '*', 'TAG': '*',
    'TGC': 'C', 'TGT': 'C', 'TGA': '*', 'TGG': 'W',
}


def construct_aa_table(dat: pd.DataFrame) -> pd.DataFrame:
    """
    Constructs a 21x21 matrix of Euclidean distances between amino acids.

    The function calculates the distance between 20 standard amino acids based on 
    12 principal components and adds a pseudo 'STOP' codon.

    Args:
        dat: A pandas DataFrame with amino acid single-letter codes as the index 
             and 12 principal components (PC1-PC12) as columns.

    Returns:
        A 21x21 pandas DataFrame containing the Euclidean distances between all 
        20 amino acids and a 'STOP' codon.
    """
    # --- FIX ---
    # Ensure that the dataframe values are numeric before calculations
    # This prevents the TypeError during vector subtraction.
    dat_numeric = dat.apply(pd.to_numeric, errors='coerce')
    # It's good practice to check if coercion created any NaN values
    if dat_numeric.isnull().values.any():
        print("Warning: Non-numeric values were found and converted to NaN.")

    # Define the constant for calculating the distance to the stop codon
    STOP_DIST = 1.5

    # Extract the list of amino acids from the input DataFrame's index
    amino_acids = dat_numeric.index.tolist()

    # Initialize an empty square DataFrame to hold the distances
    dist_matrix = pd.DataFrame(index=amino_acids, columns=amino_acids, dtype=float)

    # Calculate the Euclidean distance for each pair of amino acids
    for aa1 in amino_acids:
        for aa2 in amino_acids:
            # Retrieve the 12-dimensional vectors for the two amino acids
            vec1 = dat_numeric.loc[aa1].values
            vec2 = dat_numeric.loc[aa2].values
            
            # Compute the Euclidean distance and store it in the matrix
            distance = np.linalg.norm(vec1 - vec2)
            dist_matrix.loc[aa1, aa2] = distance

    # Find the maximum distance value among the amino acids
    max_dist = dist_matrix.values.max()

    # Calculate the distance for the stop codon
    stop_codon_dist = STOP_DIST * max_dist
    
    # Add a 'STOP' column and row to the matrix
    stop_label = '*'
    dist_matrix[stop_label] = stop_codon_dist
    dist_matrix.loc[stop_label] = stop_codon_dist
    
    # The distance from 'STOP' to itself is 0
    dist_matrix.loc[stop_label, stop_label] = 0.0

    return dist_matrix

aaSimilarity = pd.read_csv(f"{BASE_DIR}/dat/aaFeatureSpace.csv", index_col=0)
dtable = construct_aa_table(aaSimilarity)

def aaSim(aa1: str, aa2: str) -> np.float64:
    """
    aaSim(ilarity) - Looks up and returns the pre-calculated distance between two amino acids.

    Args:
        aa1: A string for the first amino acid code (e.g., 'A', '*').
        aa2: A string for the second amino acid code (e.g., 'C', '*').
        dtable: A pandas DataFrame containing the pairwise amino acid distances,
                as generated by the construct_aa_table() function.

    Returns:
        A float representing the Euclidean distance between the two amino acids.
        
    Raises:
        ValueError: If aa1 or aa2 are not found in the distance table's index.
    """
    try:
        # Use .at for fast, label-based lookup of a single value
        distance = np.float64(dtable.at[aa1, aa2])
        return distance
    except KeyError:
        # Provide a helpful error message if an amino acid code is not found
        raise ValueError(f"One or both amino acids '{aa1}', '{aa2}' not found in the distance table.")
        return -999

def create_genetic_code(sc_limit: int) -> dict:
    """
    Creates a random genetic code config that maps all 64 codons to all 
    20 amino acids and at least one stop codon.

    Args:
        sc_limit: The maximum number of stop codons allowed (the actual
                  number will be chosen randomly between 1 and sc_limit).

    Returns:
        A dictionary mapping each of the 64 codons to a single-letter 
        amino acid code or a stop codon ('*').
        
    Raises:
        ValueError: If sc_limit is not within a reasonable range (1 to 10).
    """
    # Validate the stop codon limit to a sensible range
    if not 1 <= sc_limit <= 10:
        raise ValueError("sc_limit must be between 1 and 10 for practical genetic codes.")

    # Define the building blocks for the genetic code
    bases = ['A', 'T', 'G', 'C']
    amino_acids = list("ACDEFGHIKLMNPQRSTVWY")  # 20 standard amino acids
    stop_symbol = '*'

    # 1. Generate all 64 possible codons
    all_codons = [''.join(p) for p in product(bases, repeat=3)]
    random.shuffle(all_codons)

    # 2. Determine the number of stop codons
    num_stop_codons = random.randint(1, sc_limit)

    # 3. Create the pool of assignments (amino acids + stops)
    # Ensure all 20 amino acids are present at least once
    assignments = amino_acids.copy()
    
    # Add the stop codons
    assignments.extend([stop_symbol] * num_stop_codons)

    # Fill the remaining slots with random amino acids to reach 64 total assignments
    remaining_slots = 64 - len(assignments)
    assignments.extend(random.choices(amino_acids, k=remaining_slots))
    
    # Shuffle the assignments to ensure randomness
    random.shuffle(assignments)

    # 4. Create the dictionary by mapping codons to assignments
    genetic_code = dict(zip(all_codons, assignments))
    
    return genetic_code

def score_gc(gc: dict) -> np.float64:
    """
    Calculates a 'robustness' score for a genetic code.

    The score is the sum of physicochemical distances between amino acids 
    resulting from all possible single-nucleotide point mutations across all 
    64 codons. A lower score indicates a more robust code where mutations 
    tend to result in similar amino acids.

    Args:
        gc: A dictionary mapping 64 codons to single-letter amino acid codes.
        dtable: A DataFrame containing the pairwise distances between amino acids,
                as created by the `construct_aa_table` function.

    Returns:
        A np.float64 value representing the total cost of all possible mutations.
        
    Raises:
        ValueError: If a codon in the genetic code is not found in the distance table.
    """
    bases = ['A', 'T', 'G', 'C']
    total_distance_cost: float = 0.0

    # Generate all 64 codons
    all_codons = [''.join(p) for p in product(bases, repeat=3)]

    for original_codon in all_codons:
        # Get the amino acid for the original, unmutated codon
        original_aa = gc.get(original_codon)
        if original_aa is None:
            raise ValueError(f"Codon '{original_codon}' not found in the provided genetic code.")

        # Iterate through each of the 3 positions in the codon
        for i in range(3):
            original_base = original_codon[i]
            # Iterate through each possible mutation at that position
            for mutated_base in bases:
                # We only care about actual mutations, not silent changes
                if original_base != mutated_base:
                    # Construct the mutated codon
                    mutated_codon_list = list(original_codon)
                    mutated_codon_list[i] = mutated_base
                    mutated_codon = "".join(mutated_codon_list)
                    
                    # Get the amino acid for the new, mutated codon
                    mutated_aa = gc.get(mutated_codon)
                    if mutated_aa is None:
                        raise ValueError(f"Mutated codon '{mutated_codon}' not found in the provided genetic code.")
                    
                    # Use aaSim to get the distance and add it to the total cost
                    # Note: We are directly using the dtable here as aaSim is just a lookup
                    distance: np.float64 = dtable.at[original_aa, mutated_aa]
                    total_distance_cost += distance

    return np.float64(total_distance_cost)

def random_optimization() -> np.float64:
    best: dict = create_genetic_code(STOP_CODON_LIMIT)
    best_score = score_gc(best)
    tries = 0
    while True:
        try:
            tries += 1
            test = create_genetic_code(STOP_CODON_LIMIT)
            test_score = score_gc(test)
            
            if test_score < best_score:
                best = test.copy()
                best_score = test_score
                print(f"New best! {best_score}")
                print(best)
        except KeyboardInterrupt:
            print(f"{tries} total tries")
            sys.exit()
            
def gen_and_score(times: int) -> list:
    scores = []
    while len(scores) < times:
        gc = create_genetic_code(STOP_CODON_LIMIT)
        scores.append(float(score_gc(gc)))
    return scores
   
def simulated_annealing_optimization(
      stop_codon_limit: int, 
      initial_temp: float = 10000.0, 
      cooling_rate: float = 0.999, 
      min_temp: float = 1e-4, 
      max_iterations: int = 50000
  ) -> tuple[list, list, list]:
      """
      Optimizes a genetic code using a simulated annealing algorithm to minimize mutation cost.

      Args:
          stop_codon_limit: The maximum number of stop codons for creating new codes.
          initial_temp: The starting temperature for the annealing process.
          cooling_rate: The rate at which the temperature decreases.
          min_temp: The temperature at which to stop the process.
          max_iterations: The maximum number of iterations to run.

      Returns:
          A tuple containing the final best score and a list of scores at each iteration.
      """
      # 1. Initialization
      current_code = create_genetic_code(stop_codon_limit)
      current_score = score_gc(current_code)
      
      best_code = current_code.copy()
      best_score = current_score
      
      # List to track the score at every iteration
      score_history = [current_score]
      
      print(f"Initial score: {best_score}")

      T = initial_temp
      iteration = 0
      
      try:
          # 2. Main Loop
          while T > min_temp and iteration < max_iterations:
              iteration += 1

              # 3. Generate a Neighbor State
              new_code = current_code.copy()
              codons = list(new_code.keys())
              codon1, codon2 = random.sample(codons, 2)
              new_code[codon1], new_code[codon2] = new_code[codon2], new_code[codon1]

              # 4. Score the New State
              new_score = score_gc(new_code)
              
              # 5. Decide Whether to Accept the New State
              score_delta = new_score - current_score
              
              if score_delta < 0 or random.random() < np.exp(-score_delta / T):
                  current_code = new_code
                  current_score = new_score
              
              # Update the best-ever score if the current one is better
              if current_score < best_score:
                  best_score = current_score
                  best_code = current_code.copy()
                  print(f"Iter {iteration} | Temp {T:.4f} | New best score: {best_score:.4f}")

              # Track the score of the accepted state for this iteration
              score_history.append(float(current_score))

              # 6. Cool Down
              T *= cooling_rate

      except KeyboardInterrupt:
          print("\nOptimization stopped by user.")
          sys.exit()

      finally:
          print(f"\nFinished after {iteration} iterations.")
          print(f"Final best score: {best_score}")
          return (best_score, score_history, best_code)
    

if __name__ == "__main__":
    # distance_table = construct_aa_table(dat=aaSimilarity)
    # # print(distance_table.to_string())
    # print(aaSim("A", "W", distance_table))
    # print(aaSim("W", "C", distance_table))
    
    # gc = create_genetic_code(STOP_CODON_LIMIT)
    # print(score_gc(gc))
    
    # random_optimization()
    
    runs = 10
    overall_best_score = np.inf
    overall_best_code = None
    overall_best_history = None

    try:
        for i in range(1, runs + 1):
            print(f"\nRun {i}/{runs}")
            best_score, score_history, best_code = simulated_annealing_optimization(STOP_CODON_LIMIT)

            # Store only if this run produced a strictly better score
            if best_score < overall_best_score:
                overall_best_score = best_score
                overall_best_code = best_code.copy()
                overall_best_history = score_history.copy() if score_history is not None else None
                print(f">>> New overall best after run {i}: {overall_best_score:.4f}")

    except:
        print("\nRun loop interrupted by user.")
        sys.exit()

    finally:
        print("\nOptimization complete.")
        if overall_best_code is not None:
            print(f"Overall best score: {overall_best_score:.4f}")
            # Print a small sample of the best code
            sample_items = list(overall_best_code.items())[:10]
            print("Sample of best code (first 10 codon assignments):")
            for codon, aa in sample_items:
                print(f"  {codon} -> {aa}")
        else:
            print("No successful runs produced a stored best code.")